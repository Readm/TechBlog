<!DOCTYPE html>
<html class="writer-html5" lang="zh_Hans_CN" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../../img/favicon.ico" />
    <title>Intel官方手册：CET技术预览-影子栈 - Readm's Blog</title>
    <link rel="stylesheet" href="../../../css/theme.css" />
    <link rel="stylesheet" href="../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
        <link href="../../../assets/_mkdocstrings.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Intel\u5b98\u65b9\u624b\u518c\uff1aCET\u6280\u672f\u9884\u89c8-\u5f71\u5b50\u6808";
        var mkdocs_page_input_path = "3 Old Blogs (before 2020)/Security/2016-11-09-cet-shadow_stacks.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-ET7BC0JY44"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-ET7BC0JY44');
      </script>
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../.." class="icon icon-home"> Readm's Blog
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="搜索文档" title="在此输入需要搜索的内容" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航栏">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../About/">About</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">1 漫谈CPU安全</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="#">0 引言</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../../1%20%E6%BC%AB%E8%B0%88CPU%E5%AE%89%E5%85%A8/0%20%E5%BC%95%E8%A8%80/0%20%E5%BC%95%E8%A8%80/">0 引言</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">1 通用知识</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../../1%20%E6%BC%AB%E8%B0%88CPU%E5%AE%89%E5%85%A8/1%20%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/1.1%20%E4%BB%80%E4%B9%88%E6%98%AFCPU/">1.1 什么是CPU</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../1%20%E6%BC%AB%E8%B0%88CPU%E5%AE%89%E5%85%A8/1%20%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/1.2%20CPU%E5%AE%89%E5%85%A8%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88/">1.2 CPU安全包含什么</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../1%20%E6%BC%AB%E8%B0%88CPU%E5%AE%89%E5%85%A8/1%20%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86/1.3%20%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%94%BB%E5%87%BB%E5%90%91%E9%87%8F/">1.3 威胁模型和攻击向量</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">2 计算域内安全</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../../1%20%E6%BC%AB%E8%B0%88CPU%E5%AE%89%E5%85%A8/2%20%E8%AE%A1%E7%AE%97%E5%9F%9F%E5%86%85%E5%AE%89%E5%85%A8/2.1%20%E4%BB%8E%E6%8E%A7%E5%88%B6%E6%B5%81%E5%8A%AB%E6%8C%81%E6%94%BB%E5%87%BB%E8%AE%B2%E8%B5%B7/">2.1 从控制流劫持攻击讲起</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../1%20%E6%BC%AB%E8%B0%88CPU%E5%AE%89%E5%85%A8/2%20%E8%AE%A1%E7%AE%97%E5%9F%9F%E5%86%85%E5%AE%89%E5%85%A8/2.2%20%E5%8C%BA%E5%88%86%E6%95%B0%E6%8D%AE%E4%B8%8E%E4%BB%A3%E7%A0%81/">2.2 区分数据与代码</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../1%20%E6%BC%AB%E8%B0%88CPU%E5%AE%89%E5%85%A8/2%20%E8%AE%A1%E7%AE%97%E5%9F%9F%E5%86%85%E5%AE%89%E5%85%A8/2.3%20%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E6%94%BB%E5%87%BB/">2.3 代码复用攻击</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../1%20%E6%BC%AB%E8%B0%88CPU%E5%AE%89%E5%85%A8/2%20%E8%AE%A1%E7%AE%97%E5%9F%9F%E5%86%85%E5%AE%89%E5%85%A8/2.4%20%E8%AE%A1%E7%AE%97%E5%9F%9F%E5%86%85%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1%E6%8A%80%E6%9C%AF/">2.4 计算域内安全防御技术</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">3 计算域间安全</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../../1%20%E6%BC%AB%E8%B0%88CPU%E5%AE%89%E5%85%A8/3%20%E8%AE%A1%E7%AE%97%E5%9F%9F%E9%97%B4%E5%AE%89%E5%85%A8/3.1%20%E4%BB%8E%E5%8D%95%E7%BA%AF%E7%9A%84%22%E8%AE%A1%E7%AE%97%E6%9C%BA%22%E5%BC%80%E5%A7%8B/">3.1 从单纯的"计算机"开始</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">4 可信安全和故障注入安全</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../../1%20%E6%BC%AB%E8%B0%88CPU%E5%AE%89%E5%85%A8/4%20%E5%8F%AF%E4%BF%A1%E5%AE%89%E5%85%A8%E5%92%8C%E6%95%85%E9%9A%9C%E6%B3%A8%E5%85%A5%E5%AE%89%E5%85%A8/4.1%20%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E5%8F%AF%E4%BF%A1%E8%AE%A1%E7%AE%97/">4.1 从零开始构建可信计算</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">5 侧信道安全和故障注入攻击</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../../1%20%E6%BC%AB%E8%B0%88CPU%E5%AE%89%E5%85%A8/5%20%E4%BE%A7%E4%BF%A1%E9%81%93%E5%AE%89%E5%85%A8%E5%92%8C%E6%95%85%E9%9A%9C%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/5.1%20%E4%BB%8E%22%E4%BE%A7%22%E4%BF%A1%E9%81%93%E8%AE%B2%E8%B5%B7/">从"侧"信道讲起</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../1%20%E6%BC%AB%E8%B0%88CPU%E5%AE%89%E5%85%A8/5%20%E4%BE%A7%E4%BF%A1%E9%81%93%E5%AE%89%E5%85%A8%E5%92%8C%E6%95%85%E9%9A%9C%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/5.2%20%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/">小试牛刀</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">8 杂谈</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../../1%20%E6%BC%AB%E8%B0%88CPU%E5%AE%89%E5%85%A8/8%20%E6%9D%82%E8%B0%88/8.1%20%E5%A6%82%E4%BD%95%E9%87%8F%E5%8C%96CPU%E5%AE%89%E5%85%A8/">8.1 如何量化CPU安全</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">9 反馈与合作</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../../1%20%E6%BC%AB%E8%B0%88CPU%E5%AE%89%E5%85%A8/9%20%E5%8F%8D%E9%A6%88%E4%B8%8E%E5%90%88%E4%BD%9C/%E5%8F%8D%E9%A6%88%E5%92%8C%E5%90%88%E4%BD%9C/">反馈与合作</a>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">2 杂谈</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../../2%20%E6%9D%82%E8%B0%88/%E9%9D%A2%E5%90%91%E4%BA%BA%E5%81%9A%E6%8A%80%E6%9C%AF/">以人为本做技术</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">3 Old Blogs (before 2020)</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="#">Others</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../Others/2016-09-06-prompt-in-readline/">在readline中使用颜色prompt导致显示bug</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../Others/2016-09-23-syscall/">Linux的虚拟系统调用加速</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../Others/2018-04-11-reserve-register/">如何在编译器中保留特定寄存器</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../Others/2020-02-03-huffman/">Huffman树的推广</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Security</a>
    <ul class="current">
                <li class="toctree-l2"><a class="reference internal" href="../2016-09-09-aslr-linux/">Linux下ASLR概述</a>
                </li>
                <li class="toctree-l2 current"><a class="reference internal current" href="./">Intel官方手册：CET技术预览-影子栈</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#21-sspaddress-size">2.1 影子栈指针SSP和其操作和Address Size属性</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#22">2.2 术语</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#23-near-callret">2.3 影子栈启用下的Near CALL和RET的行为</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#24-far-callret">2.4 Far CALL和RET</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#25-64">2.5 在64位模式下调用中断/异常处理程序时栈的切换</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#26">2.6 任务切换下的影子栈</a>
    </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../2020-07-27-zipper/">Zipper Stack工作介绍和反思总结</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">Riscv</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../riscv/2018-02-18-riscv-addins/">如何在RISC-V中添加一个指令</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../riscv/2018-02-18-riscv/">RISC-V 技术概览</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../riscv/2018-02-19-rocket-0/">Rocket Core源代码笔记——入门</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../riscv/2018-03-15-riscv-bypass/">Rocket Core源代码笔记——旁路</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../riscv/2018-11-19-rocket-scoreboard/">Rocket Core源代码笔记——Scoreboard</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../riscv/2018-11-20-rocket-abbrs/">Rocket Core源代码笔记——缩写</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../riscv/2018-11-21-riscv-control-flow/">Rocket Core源代码笔记——控制流</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="移动导航栏">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../..">Readm's Blog</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../.." class="icon icon-home" alt="文档"></a> &raquo;</li>
          <li>3 Old Blogs (before 2020) &raquo;</li>
          <li>Security &raquo;</li><li>Intel官方手册：CET技术预览-影子栈</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>

          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="2">2 影子栈</h1>
<p>影子栈是控制流转移指令专用的第二个栈。这个栈区别于数据栈。这个栈并不是用于存储数据的，因此其不能够被软件直接地写入。对影子栈的写入被限制为控制流转移指令和影子栈操作指令。影子栈特性可以分别地在用户态（CPL==3）和特权态（CPL&lt;3）启用。</p>
<p>影子栈操作只在开启页保护模式下启用。影子栈在virtual 8086模式下不能使用。</p>
<h2 id="21-sspaddress-size">2.1 影子栈指针SSP和其操作和Address Size属性</h2>
<p>当CET被开启并且处理器支持影子栈时时，处理器支持一个新的寄存器，影子栈寄存器SSP。SSP不能直接地在指令中被编码为源操作数，目标操作数或者内存操作。SSP指向当前影子栈顶。</p>
<p>SSP保存线性地址，并通过FAR RET，IRET和ROTORS指令加载到寄存器中。SSP必须装载到一个32位对齐的线性地址。</p>
<p>影子堆栈的宽度在32位/兼容模式下为32位，在64位模式下为64位。影子堆栈的地址大小属性在32位/兼容模式下为32位，在64位模式下为64位。</p>
<h2 id="22">2.2 术语</h2>
<p>当启用影子堆栈时，控制传输指令/流和影子堆栈管理指令会执行加载/存储到影子堆栈。 来自控制传送指令和影子堆栈管理指令的这种加载/存储被称为shadow_stack_load和shadow_stack_store，以区别于由诸如MOV，XSAVES等的其它指令执行的加载/存储。</p>
<p>用于指令操作的伪代码使用符号ShadowStackEnabled（CPL）作为在CPL处是否启用阴影堆栈的测试。 该术语返回TRUE或FALSE指示，如下所示：</p>
<pre><code>ShadowStackEnabled(CPL):
    IF CR4.CET = 1 AND CR0.PE = 1 AND EFLAGS.VM = 0
        IF CPL = 3
            THEN
                (* Obtain the shadow stack enable from MSR used to enable feature for CPL = 3 *)
                SHADOW_STACK_ENABLED = IA32_U_CET.SH_STK_EN;
            ELSE
                (* Obtain the shadow stack enable from MSR used to enable feature for CPL &lt; 3 *)
                SHADOW_STACK_ENABLED = IA32_S_CET.SH_STK_EN;
            FI;
        IF SHADOW_STACK_ENABLED = 1
            THEN
                return TRUE;
            ELSE
                return FALSE;
        FI;
    ELSE
        (* Shadow stacks not enabled in real mode and virtual-8086 mode or if the master CET feature enable in CR4 is disabled *)
        return FALSE;
    ENDIF
</code></pre>
<h2 id="23-near-callret">2.3 影子栈启用下的Near CALL和RET的行为</h2>
<p>当启用影子堆栈时，Near CALL压入返回地址到数据堆栈和影子堆栈上；Near RET 从影子堆栈和数据堆栈弹出返回地址。 如果指定了可选的“n”操作数，则数据堆栈指针（ESP / RSP）可选地进一步增加“n”个字节，但是影子堆栈指针（SSP）不递增。如果从两个堆栈弹出的返回地址不相同，那么处理器会导致#CP（near-ret）异常。</p>
<h2 id="24-far-callret">2.4 Far CALL和RET</h2>
<p>CALL指令可以用于调用位于与当前代码段不同的段中的过程，或者调用处于不同特权级别的段。</p>
<p>对于Far CALL，处理器压入影子堆栈上的CS，LIP（返回地址的线性地址）和SSP，并在远RET上从影子堆栈中弹出SSP，LIP和CS。如果CS和LIP不匹配通过从数据栈弹出CS和EIP确定的返回地址，则处理器导致#CP（FAR-RET / IRET）异常。</p>
<p>Far CALL到更高权限级别的影子堆栈行为如下：</p>
<ul>
<li>当Far CALL发起于CPL3时，返回地址不会压入到特权影子堆栈。同样，从特权级级（CPL &lt;3）到CPL3的Far RET不对返回地址进行任何验证。 在CPL3 - &gt; CPL &lt;3转换时，用户空间SSP保存到MSR - IA32_PL3_SSP，并在CPL &lt;3 - &gt; CPL3转换从该MSR恢复。</li>
<li>在特权级间CALL时，CALL指令执行栈交换。特权级的数据栈位置在当前TSS中。同样地，影子堆栈也以这种方式被切换。根据目标特权级别，从以下MSR之一获得用于特权程序的SSP<ul>
<li>IA32_PL2_SSP为切换到ring2</li>
<li>IA32_PL1_SSP为切换到ring1</li>
<li>IA32_PL0_SSP为切换到ring0</li>
</ul>
</li>
<li>从ring2到ring1，ring2到ring0或从ring1到ring0的远程调用被认为是影子栈的“相同特权级”传输。 因此，在针对新的特权级定位SSP之后的这种Far CALL将调用过程的CS，LIP和SSP压入到被调用过程的影子堆栈上。 同样，Far RET将验证来自影子栈的CS和LIP与从数据栈获得的CS和EIP确定的返回地址匹配。</li>
</ul>
<p>在跨特权远CALL上，CET在创建要用于这些传输的影子堆栈时，验证由特权用户设置的“特权影子堆栈令牌（supervisor shadow stack token）”。 特权影子栈令牌是一个64位值，结构如下：</p>
<ul>
<li>Bit 63:3 – “supervisor shadow stack token”的线性地址。</li>
<li>Bit 2 - 保留。必须置零。</li>
<li>Bit 1 - 保留。必须置零。</li>
<li>Bit 0 - Busy Bit。如果为0，则次影子栈不被任何逻辑处理器激活。</li>
</ul>
<p>下图说明了一个特权影子堆栈，位于其“特权影子堆栈令牌”基址上：</p>
<pre><code>+--------------------+          +--------------------------+
|IA32_PLx_SSP = 0xFF8|  -----&gt;  |  &lt;Next push saves here&gt;  |
+--------------------+          +--------------------------+
                                |0xFF8 | (EFER.LMA &amp;  CS.L)|
                                +--------------------------+
</code></pre>
<p>IA32_PLx_SSP中指定的地址需要为8字节对齐。在切换到编码到IA32_PLx_SSP中的特权影子堆栈之前，处理器执行以下检查。这些步骤以原子方式进行。</p>
<ol>
<li>使用shadow_stack_load从IA32_PLx_SSP中指定的地址加载管理器影子堆栈令牌。</li>
<li>Busy Bit必须为0.</li>
<li>在MSR中编码的地址必须与“特权影子堆栈令牌”中的地址匹配。</li>
<li>如果检查2和3成功，则使用shadow_stack_store设置令牌中的忙位，并将SSP切换到IA32_PLx_SSP中指定的值。</li>
<li>如果检查2或3失败，则Busy bit不置位，并产生#GP（0）异常</li>
</ol>
<p>在Far RET中，指令清除影子堆栈令牌中的忙位如下。 这些步骤也以原子方式执行：</p>
<ol>
<li>使用shadow_stack_load从SSP加载内核影子堆栈令牌。</li>
<li>检查Busy bit是否为1.</li>
<li>检查编码为“特权影子堆栈令牌”的地址是否与SSP匹配。</li>
<li>如果检查2和3成功，然后使用影子堆栈存储清除令牌中的忙位，否则继续，而不修改SSP指向的影子堆栈的内容。（译者注：而不产生异常？）</li>
</ol>
<p>这里描述的操作也适用于当通过IDT中的中断/陷阱门调用中断或异常处理程序时执行的远程调用。 同样，IRET指令的行为类似于Far RET指令。</p>
<h2 id="25-64">2.5 在64位模式下调用中断/异常处理程序时栈的切换</h2>
<p>64位模式操作提供了称为中断堆栈表（IST）的栈切换机制，其中当不存在涉及的特权改变时，64位IDT描述符可用于指定64位TSS中的7个数据堆栈指针中的一个作为调用的一部分。 如果指定的IST索引为0，并且没有涉及的特权更改，则会对同一堆栈发生栈切换。</p>
<p>为了支持这种栈切换机制，影子栈特征提供了MSR，IA32_INTERRUPT_SSP_TABLE，以编写7个影子栈指针的表的线性地址。当指定了非零IST值并且没有涉及作为调用的一部分的特权更改时，MSR指向使用IST索引索引的内存中的64字节表。</p>
<pre><code>                                    +----------------------------+
                                    |     IST7 SSP      |Offset 7|
                                    +-------------------+--------+
                                    |     IST6 SSP      |Offset 6|
                                    +-------------------+--------+
                                    |     IST5 SSP      |Offset 5|
                                    +-------------------+--------+
                                    |     IST4 SSP      |Offset 4|
                                    +-------------------+--------+
                                    |     IST3 SSP      |Offset 3|
                                    +-------------------+--------+
                                    |     IST2 SSP      |Offset 2|
                                    +-------------------+--------+
                                    |     IST1 SSP      |Offset 1|
+------------------------+          +-------------------+--------+
|IA32_INTERRUPT_SSP_TABLE|  -----&gt;  |Not used. abailable|Offset 0|
+------------------------+          +----------------------------+
</code></pre>
<h2 id="26">2.6 任务切换下的影子栈</h2>
<p>任务切换可以通过以下方式来调用：</p>
<ul>
<li>JMP和CALL到GDT中的TSS描述符</li>
<li>JMP或CALL到GDT或当前LDT中的任务门描述符</li>
<li>中断或异常向量指向IDT中的任务门描述符</li>
</ul>
<p>启用影子栈后，新任务必须与32位TSS相关联，且不能处于虚拟8086模式。用于新任务的32位SSP位于32位TSS中的偏移104处。因此，新任务的TSS必须至少为108字节。此SSP需要为8字节对齐，并且需要指向“特权影子堆栈令牌”（尽管任务可能在CPL3）。</p>
<p>在由CALL指令发起的嵌套任务切换中，旧任务的SSP不保存到旧任务TSS。相反，旧任务的SSP连同旧任务的CS和LIP一起被压入到新任务的影子堆栈上。同样，在由IRET发起的非嵌套任务切换中，新任务的SSP从旧任务的影子栈中恢复。旧任务的影子堆栈上的CS和LIP与由新任务的CS和EIP确定的返回地址匹配。如果匹配失败，则报告#CP（FAR-RET / IRET）异常。</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="页脚导航">
        <a href="../2016-09-09-aslr-linux/" class="btn btn-neutral float-left" title="Linux下ASLR概述"><span class="icon icon-circle-arrow-left"></span> 上一张</a>
        <a href="../2020-07-27-zipper/" class="btn btn-neutral float-right" title="Zipper Stack工作介绍和反思总结">下一张 <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  用<a href="https://www.mkdocs.org/">MkDocs</a>构建，使用<a href="https://readthedocs.org">Read the Docs</a>提供的<a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>。
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="版本">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../2016-09-09-aslr-linux/" style="color: #fcfcfc">&laquo; 上一张</a></span>
    
    
      <span><a href="../2020-07-27-zipper/" style="color: #fcfcfc">下一张 &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../../..';</script>
    <script src="../../../js/theme_extra.js" defer></script>
    <script src="../../../js/theme.js" defer></script>
      <script src="../../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
