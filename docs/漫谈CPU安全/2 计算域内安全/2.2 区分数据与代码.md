# 2.2 区分数据与代码

上一小节，我们总结了内存劫持攻击的几点原因

1. 首先，因为**数据**、**代码**和**返回的地址**都是等同地放在内存中的。因此攻击者写入的数据一样能够被当成代码，或者返回地址来使用。这是冯诺依曼结构决定的。
2. 其次，用户的输入变量没有被检查是否分配的空间（草稿本上的行数）是足够的。
3. 再次，用户的输入变量超出范围后，能够直接覆盖到**返回地址**，而返回地址可以指向任意的页数和行号。

这一节，我们从第一点入手，看一看能不能从这一点入手阻止控制流劫持攻击。

!!! 思考
    有种说法是认为，内存安全问题的根本原因在于冯诺依曼结构没有区分数据和代码（[出处](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%22%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E9%81%B5%E5%BE%AA%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%3A%E6%B2%A1%E6%9C%89%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E4%B8%A5%E6%A0%BC%E5%8C%BA%E5%88%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%92%8C%E6%8C%87%E4%BB%A4%22&fenlei=256&rsv_pq=0xb9063ab3000becb6&rsv_t=340e3PXWH7v0RVSGz00dFcflLl23gy1GpITqexunC1Znnz2f8Ke2v0Ua%2FI5g&rqlang=en&rsv_enter=1&rsv_dl=tb&rsv_n=2&rsv_sug3=1&rsv_sug2=0&rsv_btype=i&inputT=716&rsv_sug4=716)）。一些英文[出处1](https://info.dovermicrosystems.com/blog/von-neumann-cybersecurity) [出处2](extension://bfdogplmndidlpjfhoijckpakkdjkkil/pdf/viewer.html?file=https%3A%2F%2Fwww.forth.gr%2Fonassis%2Flectures%2F2008-07-21%2Fpresentations%2FvonNeumann_and_the_current_computer_security_landscape.pdf)。甚至保密局官网也有类似的[表述](http://www.gjbmj.gov.cn/n1/2020/1211/c411145-31963763.html)。表面上看我们当然可以归结于数据与代码的混用，但是这是否是根本问题呢？

## 数据与代码不可兼得

可以看到，我们最后攻击的时候栈的空间被我们写成了：

!!! 第5页
    行数|指令/数据
    ---|---
    ……|……
    96| 临时数据c
    97| 调用**查询今天饮料单价**返回的结果 b （这里省略了调用这个函数的过程）
    98| **预留给用户写饮料名称和数量的空间** 我叫……
    99| **第5页第100行**  <-- 篡改了的返回地址
    100| 把银行卡密码都写在第5页第20行
    101| 向用户展示第5页第20行
    ……|……

在第100行和101行，其实我们写入了代码进去，并且通过第99行的地址的改写让CPU跳到此处执行。但是其实我们可以发现，在没有攻击发生时，似乎第五页原本全是数据。那么如果我们不允许CPU在栈上读取指令是不是就可以了呢？

实际上，这就是防御控制流劫持攻击的一种非常成熟的技术：[Executable space protection](https://en.wikipedia.org/wiki/Executable_space_protection)，在不同的场合它可能被叫做 **NX bit (no-execute bit)** 或者 **Data Execution Prevention (DEP)**。基本可以试做等同的技术。这种技术比较好的实现方式是通过页表权限的配置，然后在CPU执行代码时自动检查当前页是否有执行权限。当然也不排除一些其他方式的实现，有时候也会被归类为同一个技术。目前的高性能CPU中，无论是服务器还是终端设备，都已经被广泛使用了。

进一步，我们不仅可以对栈上做此要求。其实对于内存中的所有数据，我们一般都不期望他们被当成指令（代码）来执行。记得冯诺依曼结构的定义么？其实我们最初就是把指令和代码区分来对待的。因此一个比较通用的规则是：

!!! Rule
    **Rule 2.2:**

    所有的数据，都不应该作为指令被CPU执行；
    
    所有的指令，都不应该被动态改写。

第一点我们已经解释过了。第二点，作为程序员一般情况下逻辑都是运行前固定的，因此一般自然符合；而从安全的角度考虑，攻击者需要的是一个**可以写入**并且**可以执行**的内存段，因此如果**指令部分允许写入**，那么和**数据可以执行**基本是等价的。因此也要做出限制。因此，这个技术有时候也叫做 **W^X ("write xor execute", pronounced W xor X)**，表示对一个内存页，要么可写，要么可执行，两者不可兼得。

那么如果我们正常使用程序的时候就需要同时即可写，又可执行，这种场景是否存在呢？答案是存在的，这就是[JIT (Just-in-time compilation)](https://en.wikipedia.org/wiki/Just-in-time_compilation)技术。不幸的是，这种技术对于非常多的场景的性能提升至关重要，因此这里安全与性能的冲突就十分麻烦。前些年CFI技术在学术界还比较火的时候，很多比较棘手的问题都是JIT场景下出现的，这里我们先不离题太远了。

## 魔高一丈

的确，有了这种代码与数据的区分后，上一小节我们提到的攻击似乎无法奏效了。因为我们的第100行和后面的恶意代码不能够被执行了。如果仍然这样攻击，CPU其实还是会跳转过去，只是刚要开始执行，突然幡然醒悟这可不是代码页：“这指令可不兴执行啊”。